# Clean Code 📚
> 애자일 소프트웨어 장인 정신 

> 전자책으로 구매해서, pdf페이지와 실제 페이지를 함께 기입

<br>

## 목차 📝
1. [추천사](##-추천사-👍)
2. [깨끗한 코드](##-1장.-깨끗한-코드)
3. [의미 있는 이름](##-2장.-의미-있는-이름)
4. [함수](##-3장.-함수)
5. [주석](##-4장.-주석)
6. [형식 맞추기](##-5장.-형식-맞추기)
7. [객체와 자료 구조](##-6장.-객체와-자료-구조)
8. [오류 처리](##-7장.-오류-처리)
9. [경계](##-8장.-경계)
10. [단위 테스트](##-9장.-단위-테스트)

<br>

## 추천사 👍
### 기억에 남는 부분 🤩
- 소프트웨어는 80% 이상이 유지보수다. ``24page``
- 일관적인 들여쓰기 스타일이 버그 수를 줄여주는 가장 중요한 요인 중 하나 ``28page``
- 코드 품질을 측정하는 유일한 척도 = 분당 내지르는 WTF 횟수! ``32page``

### 새롭게 배운 내용 💡
- 5S원칙
  - 린(Lean)의 토대
    - 서양 개발 문화가 내놓은 또다른 유행이자 소프트웨어 개발자들 사이에서 주목받는 유행
  1.  정리 또는 조직 : 적절한 명명법
  2.  정돈 또는 단정함 : 코드는 예상하는 위치에 있어야 한다.
  3.  청소 또는 정리 : 작업 중 쓰레기는 치운다! 과거나 미래를 위해 주석처리해놓은 코드는 시원하게 삭제한다!
  4.  청결 또는 표준화 : 일관적인 구현스타일과 기법의 필요성
  5.  생활화 또는 규율 : 관례를 따르고 작품을 자주 돌아본다.

### 소감 💬
- 평소 프로젝트를 진행 할 때, 아무래도 마감시간이 지켜저있기 때문에 일단 돌아가게만 만드는 경우가 많았는데 이런 나의 태도를 반성하게 된다. 나중으로 미뤄봤자 어차피 하지 않는다는 것을 알고있었는데... 앞으로 우아하고 멋진 클린코드를 작성하기 위해 더욱 노력해야겠다고 생각한다.



<br>

## 1장. 깨끗한 코드 

### 기억에 남는 부분 🤩
- 나쁜 코드가 쌓일수록 팀 생산성은 떨어진다. 그러다가 마침내 0에 근접한다. ``40/p.5``
- 좋은 코드를 사수하는 일은 바로 우리 프로그래머들의 책임이다. ``42/p.7``
- 코드는 시간이 지나도 언제나 깨끗하게 유지해야 한다. 보이스카우트 규칙 ``53/p.18``

### 새롭게 배운 내용 💡
- 타이거 팀
  - 타이거팀이란 새로운 소프트웨어 또는 하드웨어 등에서 보안상의 취약점을
찾아내기 위해 만들어진 각 분야의 전문가로 구성된 '전문가 팀'을 말합니다. [출처](http://www.tigerteam.kr/)

### 소감 💬
- 보이스카우트 규칙으로 적혀있는 ``캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라.`` 부분이 무척 인상깊었다. <br>앞으로 코드를 작성할 때 보다 주의깊게 생각하고 진행해야겠다.

<br>

## 2장. 의미 있는 이름

### 기억에 남는 부분 🤩
- 좋은 이름을 지으려면 시간이
걸리지만 좋은 이름으로 절약하는 시간이 훨씬 더 많다. ``57/p.22``
- Info나 Data는 a, an, the
와 마찬가지로 의미가 불분명한 불용어다. ``61/p.26``
- 읽는 사람이 차이를 알도록 이름을 지어라. ``62/p.27``

### 새롭게 배운 내용 💡
- 불용어
  - 인터넷 검색 시 검색 용어로 사용하지 않는 단어. 관사, 전치사, 조사, 접속사 등 검색 색인 단어로 의미가 없는 단어 [출처](https://terms.naver.com/entry.naver?docId=857191&cid=50371&categoryId=50371)
- 헝가리식 표기법 [출처](https://namu.wiki/w/%ED%97%9D%EA%B0%80%EB%A6%AC%EC%95%88%20%ED%91%9C%EA%B8%B0%EB%B2%95)
  - 변수 및 함수의 인자 이름 앞에 데이터 타입을 명시하는 코딩 규칙
    - b : byte, boolean / ch : char 등
- IDE (Integrated Development Environment)
  - 공통된 개발자 툴을 하나의 그래픽 사용자 인터페이스로 결합하는 애플리케이션을 구축하기 위한 소프트웨어 [출처](https://www.redhat.com/ko/topics/middleware/what-is-ide)
### 다시 한번 찾아본 내용 🔎
- 컴파일러
  -  고급언어로 쓰인 프로그램을 그와 의미적으로 동등하며 컴퓨터에서 즉시 실행될 수 있는 형태의 목적 프로그램으로 바꾸어 주는 번역 프로그램. [출처](https://terms.naver.com/entry.naver?cid=40942&docId=1149675&categoryId=32837)
- 인터프리터
  - 프로그램을 해석하는 방법 중 하나로, 사람이 이해할 수 있는 고급언어로 작성된 코드를 한 단계씩 해석하여 실행시키는 방법을 말한다. [출처](https://terms.naver.com/entry.naver?cid=40942&docId=3434801&categoryId=32838)
- 부동소수점
  - 컴퓨터에서 실수를 표현하기위한 방법 중 하나. 컴퓨터에서는 실수를 정수와 마찬가지로 2진수로만 표시해야하기 때문이다. [출처](http://www.tcpschool.com/cpp/cpp_datatype_floatingPointNumber) 


### 소감 💬
- 평소 변수명 등 이름을 지을 때, Data, Info 등 자신이 생각해도 추후 유지보수에 안좋은 네이밍을 사용했고, 사용하면서 시간이 모자르니까 어쩔 수 없다고만 생각했는데 이번에 깨끗한 코드 부문을 보며 앞으로 괜히 탓하지 말고 더욱 네이밍에 신경써야겠다고 생각이 들었다. 하나하나 신경쓰는 부분이 많아지고 완성도 높은 코드를 제작하기위해 노력해야겠다는 생각이 많아졌고 더욱 더 훌륭하고 우아한 개발자가 되고싶다.

<br>

## 3장. 함수

### 기억에 남는 부분 🤩
- 함수를 만드는 첫째 규칙은 ‘작게!’다. 함수를 만드는 둘째 규칙은 ‘더 작게!’다. ``77/p.42``
- **한 가지만 해라!** 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해
야 한다. ``79/p.44``
- **위에서 아래로 코드 읽기: 내려가기 규칙** 코드는 위에서 아래로 이야기5처럼 읽혀야 좋다 ``81/p.46``
- 워드가 말했던 원칙을 기억하는가? **“코드를 읽으면서 짐작했던 기
능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다.”**  ``84/p.49``
- 함수에서 이상적인 인수 개수는 0개(무항)다 ``85/p.50``
- **명령과 조회를 분리하라!** 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다 ``91/p.56``
- 오류 코드보다 예외를 사용하라! ``92/p.57``
- 소프트웨어를 짜는 행위는 여느 글짓기와 비슷하다. ``96/p.61``
- 여기서 설명한 규칙을 따른다면 길이가 짧고, 이름이 좋고, 체계가 잡힌 함수가 나오리라. 하지만 진짜 목표는 시스템이라는 이야기를 풀어가는 데 있다는 사실을 명심하기 바란다 ``97/p.62``

### 새롭게 배운 내용 💡
- FitNesse
  - 오픈소스 인수테스트 자동화 도구 [출처](https://wiblee.tistory.com/entry/FitNesse%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%9D%B8%EC%88%98%ED%85%8C%EC%8A%A4%ED%8A%B8)
  - 인수 테스트를 QA팀이 진행하였으나, 수동적인 테스트 및 인력 증가 그로인한 비용이 증가되어 테스트 자동화도구 도입의 필요성이 대두되었는데, 이 때 해당 도구 같은 인수 테스트 자동화 도구들이 나타났다.
- 인수테스트
  - 명세화된 요구사항이 충족되었는지 확인하는 테스트 [출처](https://wiblee.tistory.com/entry/FitNesse%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%9D%B8%EC%88%98%ED%85%8C%EC%8A%A4%ED%8A%B8)
- 플래그 인수
  - 플래그 인수는 함수에 Bool / String / Enum 등을 함께 넘겨서 로직을 분기하는 방법 [출처](https://cozzin.tistory.com/74)

### 다시 한번 찾아본 내용 🔎
- 추상화
  - 실세계의 복잡한 상황을 간결하고 명확하게 핵심 위주로 단순화시킴 [출처](http://www.ktword.co.kr/test/view/view.php?m_temp1=3026)


### 소감 💬
- 클린코드는 정말 이름의 중요성을 여러번 강조하는 책인 것 같다. 실제로 프로젝트를 진행하면서 이름때문에 골머리를 앓은적이 몇번 있어서 공감이 많이 간다. 이번 책을 보면서 따로 공부하지는 않았었지만 개인적으로 좀 더 코드를 깔끔하게 하기위해 노력한 영역이 있는데 해당 부분과 책에서 설명해주는 부분 중 동일한 것이 많아 혼자서 놀라웠고 미리 알았으면 좋았을텐데.. 라는 아쉬움도 든다. 앞으로 더욱 공부를 열심히해야겠다는 생각이 든다!! 나자신에게 화이팅이라는 말을 해주고싶다!


<br>

## 4장. 주석

### 기억에 남는 부분 🤩
- 오래되고 조잡한 주석은 거짓과 잘못된 정보를 퍼뜨려 해악을 미친다. ``103/p.68``
- 프로그래머들이 주석을 엄격하게 관리해야 한다고, 그래서 복구성과 관련성과 정확성이 언제나 높아야 한다고 주장할지도 모르겠다. 그 의견에 동의한다. 프로그래머들에게도 절도가 필요하다. 하지만 나라면 코드를 깔끔하게 정리하고 표현력을 강화하는 방향으로, 그래서 애초에 주석이 필요 없는 방향으로 에너지를 쏟겠다. ``104/p.69``
- 물론 요즘에는 @Ignore 속성을 이용해 테스트 케이스를 꺼버린다. 구체적인 설명은 @Ignore 속성에 문자열로 넣어준다. 예를 들어, @Ignore(“실행이 너무 오래 걸린다.”)라고 쓴다. 하지만 JUnit4가 나오기 전에는 메서드 이름 앞에 _ 기호를 붙이는 방법이 일반적인 관례였다. 위에 제시한 주석은 (다소 경박하지만) 매우 적절한 지적이다 ``109/p.74``
- 때로는 ‘앞으로 할 일’을 //TODO 주석으로 남겨두면 편하다. ``109/p.74``
- TODO로 떡칠한 코드는 바람직하지 않다. 그러므로 주기적으로 TODO 주석을 점검해 없애도 괜찮은 주석은 없애라고 권한다. ``110/p.75``
- 주석을 달기로 결정했다면 충분한 시간을 들여 최고의 주석을 달도록 노력한다. ``111/p.76``
- 답을 알아내려면 다른 코드를 뒤져보는 수밖에 없다. 이해가 안 되어 다른 모듈까지 뒤져야 하는 주석은 독자와 제대로 소통하지 못하는 주석이다. 그런 주석은 바이트만 낭비할 뿐이다. ``111/p.76``
-  주석이 코드보다 더 많은 정보를 제공하지 못한다. ``112/p.77``
- 모든 함수에 Javadocs를 달거나 모든 변수에 주석을 달아야 한다는 규칙은 어리석기 그지없다. 이런 주석은 코드를 복잡하게 만들며, 거짓말을 퍼뜨리고, 혼동과 무질서를 초래한다. ``115/p.80``
- 있으나 마나 한 주석을 달려는 유혹에서 벗어나 코드를 정리하라. 더 낫고, 행복한 프로그래머가 되는 지름길이다. ``118/p.83``
- 함수나 변수로 표현할 수 있다면 주석을 달지 마라 ``119/p.84``
- 소스 코드 관리 시스템은 누가 언제 무엇을 추가했는지 귀신처럼 기억한다. 저자 이름으로 코드를 오염시킬 필요가 없다. ``121/p.86``
- 주석으로 처리된 코드는 다른 사람들이 지우기를 주저한다. 이유가 있어 남겨놓았으리라고, 중요하니까 지우면 안 된다고 생각한다. 그래서 질 나쁜 와인병 바닥에 앙금이 쌓이듯 쓸모 없는 코드가 점차 쌓여간다 ``121/p.86``
- 소스 코드 관리 시스템이 우리를 대신해 코드를 기억해준다. 이제는 주석으로 처리할 필요가 없다. 그냥 코드를 삭제하라. 잃어버릴 염려는 없다. 약속한다. ``122/p.87``
- 주석에다 흥미로운 역사나 관련 없는 정보를 장황하게 늘어놓지 마라 ``123/p.88``
- 주석을 다는 목적은 코드만으로 설명이 부족해서다. ``124/p.89``

### 새롭게 배운 내용 💡
- 쉰들러 리스트
  -  쉰들러라는 인물이 유대인의 목숨을 구하는 내용이 담긴 영화

### 다시 한번 찾아본 내용 🔎
- 추상 메서드
  - 자식 class에서 반드시 오버라이딩을 해야만 사용할 수 있는 class

### 소감 💬
- 평소 유지보수와 추후 개발 및 다른사람이 내 코드를 볼 때를 대비해서 주석을 작성하도록 노력하는 편이다.
그런데 해당 내용을 보니 잘못 생각했다는 기분이 들었다. 확실히 이번에 클린코드를 보면서 네이밍에 신경을 써서 작성했더니 보다 쉽게 어떤 함수이고 어떤 변수인지 알 수 있었다. 앞으로 특별한 일이 아니면 주석을 달지 않고 최대한 코드로 풀어낼 수 있도록 **신문기사**처럼! **위에서 아래로 부드럽게** 읽힐 수 있도록!! 작성하도록 노력해야겠다!! :)

<br>

## 5장. 형식 맞추기

### 기억에 남는 부분 🤩
- 프로그래머라면 형식을 깔끔하게 맞춰 코드를 짜야 한다. 코드 형식을 맞추기  위한 간단한 규칙을 정하고 그 규칙을 착실히 따라야 한다. 팀으로 일한다면 팀 이 합의해 규칙을 정하고 모두가 그 규칙을 따라야 한다. 필요하다면 규칙을 자 동으로 적용하는 도구를 활용한다. ``131/p.96``
- 코드 형식은 의사소통의 일환이다. 의사소통은 전문 개발자의 일차적인 의무다. ``131/p.96``
- 오늘 구현한 기능이 다음 버전에서 바뀔 확률은 아주 높다. ``131/p.96``
- 원래 코드는 사라질지라도 개발자의 스타일과 규율은 사라지지 않는다. ``131/p.96``
- 원활한 소통을 장려하는 코드 형식 ``131/p.96``
  1. 적절한 행 길이를 유지하라 
  2. 신문 기사처럼 작성하라
    - 이름은 간단하면서도 설명이 가능하게 짓는다.
  3. 개념은 빈 행으로 분리하라
    - 빈 행은 새로운 개념을 시작한다는 시각적 단서
  4. 세로 밀집도
    - 줄바꿈이 개념을 분리한다면, 세로 밀집도는 연관성을 의미한다.
    - 서로 밀접한 코드 행은 세로로 가까이 놓여야 한다는 뜻이다.
  5. 수직 거리
    - 서로 밀접한 개념은 세로로 가까이 둬야 한다.
    - 같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성을 표현
  6. 변수 언언
    - 변수는 사용하는 위치에 최대한 가까이 선언
  7. 인스턴스 변수
    - 클래스 맨 처음에 선언한다,
  8. 종속 함수
    - 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치.
    - 호출**하는** 함수를 호출**되는** 함수보다 먼저 배치
  9. 개념적 유사성
    - 개념적인 친화도가 높을수록 코드를 가까이 배치.
    - 친화도가 높은 요인은 여러가지이나, 한 함수가 다른함수를 호출해 생기는 직접적인 종속성이 한 예
  10. 세로 순서
    - 호출**되는** 함수를 호출 **하는** 함수보다 나중에 배치하면, 소스 코드 모듈이 고차원에서 저차원으로 자연스럽게 내려감.
    - 가장 중요한 개념을 먼저 표현. 이 때, 세세한 사항은 최대한 배제
    - 세세한 사항은 가장 마지막에 표현
  11. 가로형식 맞추기
  12. 팀 규칙
    - 팀에 속한다면 자신이 선호해야 할 규칙은 팀 규칙.
    - 어디이 괄호를 넣고 들여쓰기는 몇자고 클래스,변수,메서드 이름은 어떻게 지을지 등

### 새롭게 배운 내용 💡
- 언어별 인스턴스변수 선언 방식
  - C++
    - 모든 인스턴스 변수를 클래스 마지막에 선언하는 ``가위규칙`` 을 적용
  - JAVA
    - 보통 클래스 맨 처음에 인스턴스 변수 선언

### 다시 한번 찾아본 내용 🔎
- 표준편차
  - 자료가 많을 때 자료를 대표하는 하나의 값,즉 대푯값으로 평균을 많이 사용한다. 산포도의 하나인 표준편차는 자료가 평균을 중심으로 얼마나 퍼져 있는지를 나타내는 대표적인 수치이다. [출처](https://terms.naver.com/entry.naver?docId=3405400&cid=47324&categoryId=47324)
- 인스턴스 변수


### 소감 💬
- 평소 코드를 작성할 때 혼자서 코드를 좀 더 보기 편하려고 여러 설정과 나만의 규칙으로 코드를 작성하는데 그것과 관련된 내용이 책에도 나와서 조금 놀랐다, 다 똑같은 생각을 하고 좀 더 보기 쉽고 접근하기 쉽도록 노력을 한다고 느꼈다.
- 특히 가로세로 형식에 나와있는 코드를 읽을 때, 확실히 들여쓰기와 행 구분 등을 활용하니 코드가 더욱 보기 쉽게 짜졌다,
- 앞으로 이번 책에서 읽은 형식맞추기를 통해 나의 코드도 더욱 좋게 제작하고싶다,

<br>

## 6장. 객체와 자료 구조

### 기억에 남는 부분 🤩
- 변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않는다. `154/p.119`
- 개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을 심각하게 고민해야 한다. `154/p.119`
- (자료 구조를 사용하는) 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다. `157/p.122`
- 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 한다. 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다. `157/p.122`
- 객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다! `157/p.122`
- 객체는 동작을 공개하고 자료를 숨긴다, `162/p.127`
- 시스탬을 구현할 때, 새로운 **자료 타입을 추가**하는 유연성이 필요하면 **객체**가 더 적합하며,  
새로운 **동작을 추가**하는 유연성이 필요하면 **자료 구조**와 **절차적인 코드**가 더 적합하다. ``163/p.128`


### 새롭게 배운 내용 💡
- 직교좌표계
  - 좌표계 종류 중 하나로, 바둑판 모양에 좌표를 찍는 종류이다. [출처](https://terms.naver.com/entry.naver?docId=4125450&cid=60207&categoryId=60207)
- 극좌표계
  - 공간 위치가 원점으로부터의 거리와 방향에 의해서 표현된 좌표계를 말한다. [출처](https://terms.naver.com/entry.naver?docId=3481002&cid=58439&categoryId=58439)
- 객체 지향 설계자
  - VISITOR [출처](https://blog.naver.com/mycho/221867357787)
    - Visitor 패턴은 알고리즘을 작동하는 오브젝트와 알고리즘을 분리 할 수있는 행동 설계 패턴이다.
    - 새로운 메서드를 기존 컴포넌트 클래스에 통합하지 않고 visitor라는 별도의 클래스에 배치한다,
  - Dual-Patch
- 디미터 법칙
  - 디미터 법칙은 잘 알려진 휴리스틱으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙
- 자료 전달 객체 Data Transfer Object, DTO
  - 자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스


### 소감 💬
- 평소 코드를 작성할 때, 노출이 되어야하는지 안되어야하는지, 어떤것에 중점을 두고 유연성을 주어야하는지 따로 생각하는 방식이 중요하다는 것을 느끼게 되었다,  
항상 배울게 많고 배우면 배울수록 어려운 공부가 개발공부라고 생각은 항상 했었지만 이번에 그 내용을 실감한 것 같다. 

<br>

## 7장. 오류 처리
### 기억에 남는 부분 🤩
- 입력이 이상하거나 디바이스가 실패할지도 모르기 때문에 오류처리는 프로그램에 반드시 필요한 요소 중 하나이다. ``165/p.130``
- 오류 코드보다 예외를 사용하라 ``165/p.130``
- 뒤섞인 개념을 분리해야 코드가 확실히 깨끗해 진다. ``167/p.132``
- 오류처리는, Try-Catch-Finally문 부터 작성하라 ``167/p.132``
  - try 블록에서 무슨일이 생기든지 catch 블록은 프로그램 상태를 일관성있게 유지해야 한다.
- 예외에 의미를 제공하라 ``170/p.135``
  - 예외를 던질 때는 전후 상황을 충분히 덧붙인다.
  - 오류 메시지에 정보를 담아 예외와 함께 던진다.  
  실패한 연산이름과 실패 유형도 함께 언급한다.
- 호출자를 고려해 예외 클래스를 정의하라 ``170/p.135``
  - 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 **오류를 잡아내는 방법**이 되어야한다.
- null을 반환하지 마라 ``173/p.138``
  - null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다.
- null을 전달하지 마라 ``175/p.140``
  - 인수로 null이 넘어오면 코드에 문제가 있다는 말. 이런 정책을 따르면 그만큼 부주의한 실수를 저지를 확률도 작아진다.
- 결론 ``177/p.142``
  - 깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다.
  - 오류처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다.
  - 오류 처리를 프로그램 논리와 분리하면 독립적인 추론이가능해지며 코드 유지보수성도 크게 높아진다.

### 새롭게 배운 내용 💡
- OCP (Open Closed Principle
  - 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다. [출처](https://nesoy.github.io/articles/2018-01/OCP)
- 특수 사례 패턴 (Special Case Pattern)
  - 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식 [예시](https://pjh3749.tistory.com/237)

### 다시 한번 찾아본 내용 🔎
- Method
  - 개발자가 특정한 행동을 정의하면 그 행동을 호출하면 프로그램에서 그대로 실행하는 것을 의미 [출처](https://crazykim2.tistory.com/518)

### 소감 💬
- **null을 반환하지 마라** 그리고 **null을 전달하지 마라** 부분에서 많은 것을 느끼게 되었다.  
 평소 코드를 작성할 때, 하나의 메소드에서 인수값이 null인지, null이 아닌지에 대해 type을 나눠서 작성했었는데, 생각해보니 인수에 type을 추가하거나 다른 방법을 쓰면 될텐데 왜 그렇게 사용을 했었는지 나자신에게 의문이 생긴다.
 - 책을 읽다보면 나 자신이 객관화가 되며 고쳐야하는 부분이 무엇인지 꽤 정확하게 보인다고 생각한다. 앞으로 코드를 작성할 때 더 주의하면서 작성해야겠다!!

<br>

## 8장. 경계

### 기억에 남는 부분 🤩
- 소프트웨어 경계를 깔끔하게 처리하는 기법과 기교
- **외부코드 사용하기** ``179/p.144``
  - 제공자는 적용성을 최대한 넓히려한다. 더 많은 환경에서 돌아가야 많은 고객들이 구매하기 때문
  - 사용자는 자신의 요구에 집중하는 인터페이스를 바란다

### 새롭게 배운 내용 💡
- 제네릭스 [출처](https://developer-alle.tistory.com/216)
  - 다양한 타입의 객체를 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크(compile-time type check)를 해주는 기능이다. 제네릭 타입은 클래스와 메서드에 선언할 수 있다.
- 학습 테스트
  - 우리쪽 코드를 작성해 외부 코드를 호출하는 대신, 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히는 방법  
    짐 뉴커크는 이를 **학습 테스트**라고 부른다.
- ADAPTER 패턴 [출처](https://jusungpark.tistory.com/22)  
  - 한 클래스의 인터페이스를 클라이언트에서 사용하고자하는 다른 인터페이스로 변환한다.  
    어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.

### 소감 💬
- 외부 라이브러리를 갖고와서 데이터를 가공해 코드를 작성할 때, 외부 코드로 인해 내부 코드를 바꿔야했던 일도 있었던 적이 있었다.  
지금 해당 부분을 읽고 다시 생각해보니 내부에서 코드를 변경하는 메소드를 하나 더 생성해서 진행했으면 어땠을까라는 생각이 들었다.  
이전에 작성했던 방식은 내부에서 외부로 너무 의존성이 강했던 것 같다. 외부 코드를 아예 변경해야하는 일이 있었다면 정말 대규모 변경이 필요했었을 것 이다.


<br>

## 9장. 단위 테스트

### 기억에 남는 부분 🤩
- TDD 법칙 세가지 ``190/p.155``
  1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
  2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위테스트를 작성한다.
  3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
- 깨끗한 테스트 코드 유지하기 ``191/p.156``
  - 테스트 코드는 실제 코드 못지 않게 중요하다.
  - 테스트는 유연성, 유지보수성, 재사용성을 제공한다.
    - 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위테스트 이다.
- 깨끗한 테스트 코드 ``193/p.158``
  - 깨끗한 테스트 코드를 제작하기위한 세가지 >> **가독성, 가독성, 가독성**
- 테스트 당 개념 하나 ``201/P.166``
  - 테스트 함수마다 한 개념만 테스트 하라.
- 테스트 코드는 실제 코드의 유연성, 유지보수성, 재사용성을 보존하고 강화하기 때문에 실제코드보가 더 중요할지도 모른다. ``203/p.168``
- 테스트 코드는 지속적으로 깨끗하게 관리하자!

### 새롭게 배운 내용 💡
- BUILD-OPERATE-CHECK 패턴
- F.I.R.S.T 깨끗한 테스트를 위한 5가지 규칙
  - **빠르게**(Fast) :  
  테스트는 빨라야한다. 빨리 돌아야 한다.
  - **독립적으로**(Independent) :  
  각 테스트는 서로 의존하면 안된다.  
  하나가 실패할 때, 나머지도 잇달아 실패하므로 원인을 진단하기가 어려워진다.
  - **반복가능하게**(Repeatable) :  
  테스트는 어떤 환경에서도 반복 가능해야 한다.
  - **자가검증하는**(Self-Validation) :  
  테스트는 ``boolean`` 값으로 결과를 내야한다. 통과여부를 알려고 로그파일을 읽게 만들어서는 안된다.
  - **적시에**(Timely) :  
  테스트는 적시에 작성해야한다.

### 소감 💬
- 테스트 코드에 대해 더욱 배울 수 있는 주제가 되었다.  
아직 테스트 코드를 작성하지는 않지만 추후에 작성할 일이 생긴다면 위 내용을 생각하며 지켜야 하는 테스트 코드 작성법을 최대한 지키면서 완성도 높은 코드를 제작하고 싶다.